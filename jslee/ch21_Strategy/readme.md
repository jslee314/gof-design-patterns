
# Strategy

## :bell: Intent
전략은 일련의 알고리즘을 정의하고 각 알고리즘을 별도의 클래스에 넣고 해당 객체를 교환할 수 있도록 하는 행동 디자인 패턴입니다.
전략 패턴에서는 다양한 전략을 나타내는 객체와 전략 객체에 따라 동작이 달라지는 Context 객체를 생성합니다. 전략 객체는 Context 객체의 실행 알고리즘을 변경합니다.

## :bell: Implement  
행동을 정의하는 전략 인터페이스와 전략 인터페이스를 구현하는 구체적인 전략 클래스를 만들 것입니다. 컨텍스트는 전략을 사용하는 클래스입니다.
데모 클래스인 StrategyPatternDemo는 Context 및 전략 개체를 사용하여 배포하거나 사용하는 전략에 따라 Context 동작의 변화를 보여줍니다.


## :balloon: Structure of classes
<img width="550" alt="image" src="https://user-images.githubusercontent.com/40026846/171395932-aa05a025-7454-42e7-aed8-071aec95b25a.png">


1. `Context`   
- Context는 구체적인 전략 중 하나에 대한 참조를 유지하고 전략 인터페이스를 통해서만 이 객체와 통신합니다. (navigator)

2. `Strategy interface`     
- 전략 인터페이스는 모든 구체적인 전략에 공통입니다. Context가 전략을 실행하는 데 사용하는 방법을 선언합니다.

3. `Concrete Strategies`     
- 구체적인 전략은 컨텍스트가 사용하는 알고리즘의 다양한 변형을 구현합니다.  


4. 컨텍스트는 알고리즘을 실행해야 할 때마다 연결된 Strategy 객체의 실행 메서드를 호출합니다. 컨텍스트는 어떤 유형의 전략과 함께 작동하는지 또는 알고리즘이 어떻게 실행되는지 모릅니다.
  
5. `Client`   
- 클라이언트는 특정 전략 개체를 생성하여 컨텍스트에 전달합니다. 컨텍스트는 클라이언트가 런타임에 컨텍스트와 관련된 전략을 대체할 수 있도록 하는 설정자를 노출합니다.


## :balloon: Applicability
(1) 객체 내에서 다양한 알고리즘 변형을 사용하고 런타임 중에 한 알고리즘에서 다른 알고리즘으로 전환할 수 있도록 하려는 경우 전략 패턴을 사용합니다.   

(2) 일부 동작을 실행하는 방식만 다른 유사한 클래스가 많이 있는 경우 전략을 사용합니다.   

(3)  패턴을 사용하여 해당 로직의 컨텍스트에서 중요하지 않을 수 있는 알고리즘의 구현 세부사항에서 클래스의 비즈니스 로직을 분리하십시오.   

(4)  클래스에 동일한 알고리즘의 다른 변형 간에 전환하는 대규모 조건부 연산자가 있는 경우 패턴을 사용합니다.    



## :balloon: Releations with Other Patterns
- `Bridge`, `State`, `Strategy`(그리고 어느 정도 `Adapter`)는 매우 유사한 구조를 가지고 있습니다. 실제로 이러한 모든 패턴은 `작업을 다른 개체에 위임`하는 구성을 기반으로 합니다. 그러나 그들은 모두 다른 문제를 해결합니다. 패턴은 특정 방식으로 코드를 구조화하기 위한 단순한 레시피가 아닙니다. 또한 패턴이 해결하는 문제를 다른 개발자에게 전달할 수도 있습니다.  

- `Command`과 `Strategy`은 둘 다 사용하여 일부 작업으로 개체를 매개변수화할 수 있기 때문에 비슷해 보일 수 있습니다. 그러나 그들은 매우 다른 의도를 가지고 있습니다.

    - Command를 사용하여 모든 작업을 개체로 변환할 수 있습니다. 작업의 매개변수는 해당 개체의 필드가 됩니다. 변환을 통해 작업 실행을 연기하고, 대기열에 넣고, 명령 기록을 저장하고, 원격 서비스에 명령을 보내는 등의 작업을 수행할 수 있습니다.

    - 반면에 전략은 일반적으로 동일한 작업을 수행하는 다른 방법을 설명하므로 단일 컨텍스트 클래스 내에서 이러한 알고리즘을 교환할 수 있습니다.

- `Decorator`를 사용하면 개체의 `겉`을 변경할 수 있고 `Strategy`를 사용하면 `속`을 변경할 수 있습니다.

- `Template Method`는 상속을 기반으로 합니다. 이를 통해 하위 클래스에서 해당 부분을 확장하여 알고리즘의 일부를 변경할 수 있습니다. 전략은 구성을 기반으로 합니다. 해당 동작에 해당하는 다른 전략을 제공하여 개체 동작의 일부를 변경할 수 있습니다. 템플릿 메서드는 클래스 수준에서 작동하므로 정적입니다. 전략은 개체 수준에서 작동하므로 런타임에 동작을 전환할 수 있습니다.

- `State`는 전략의 확장으로 간주될 수 있습니다. 두 패턴 모두 구성을 기반으로 합니다. 일부 작업을 도우미 개체에 위임하여 컨텍스트의 동작을 변경합니다. 전략은 이러한 개체를 완전히 독립적으로 만들고 서로를 인식하지 못하게 합니다. 그러나 State는 구체적인 상태 간의 종속성을 제한하지 않고 컨텍스트의 상태를 마음대로 변경할 수 있습니다.

## :bulb: Java Library
java.util.Comparator#compare(), executed by among others Collections#sort().
javax.servlet.http.HttpServlet, the service() and all doXXX() methods take HttpServletRequest and HttpServletResponse and the implementor has to process them (and not to get hold of them as instance variables!).
javax.servlet.Filter#doFilter()


